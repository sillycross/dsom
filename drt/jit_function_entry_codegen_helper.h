#pragma once

#include "common_utils.h"
#include "deegen_options.h"

struct JitFunctionEntryLogicTraits
{
    using EmitterFn = void(*)(void* /*fastPathPtr*/, void* /*slowPathPtr*/, void* /*dataSecPtr*/);
    uint16_t m_fastPathCodeLen;
    uint16_t m_slowPathCodeLen;
    uint16_t m_dataSecCodeLen;
    EmitterFn m_emitterFn;
};
static_assert(sizeof(JitFunctionEntryLogicTraits) == 16);

// If the function takes <= threshold fixed parameters, it will use the specialized function entry logic implementation
// In debug mode, make the threshold smaller so there is more chance to test the generic implementation
//
constexpr size_t x_jitFunctionEntrySpecializeThresholdForNonVarargsFunction = x_use_som_call_semantics ? 0 : (x_isDebugBuild ? 3 : 10);
constexpr size_t x_jitFunctionEntrySpecializeThresholdForVarargsFunction = x_use_som_call_semantics ? 0 : (x_isDebugBuild ? 3 : 10);

// These tables are generated by Deegen
//
extern const JitFunctionEntryLogicTraits deegen_baseline_jit_function_entry_logic_trait_table_nova[x_jitFunctionEntrySpecializeThresholdForNonVarargsFunction + 2];
extern const JitFunctionEntryLogicTraits deegen_baseline_jit_function_entry_logic_trait_table_va[x_jitFunctionEntrySpecializeThresholdForVarargsFunction + 2];
extern const JitFunctionEntryLogicTraits deegen_dfg_jit_function_entry_logic_trait_table_nova[x_jitFunctionEntrySpecializeThresholdForNonVarargsFunction + 2];
extern const JitFunctionEntryLogicTraits deegen_dfg_jit_function_entry_logic_trait_table_va[x_jitFunctionEntrySpecializeThresholdForVarargsFunction + 2];

inline JitFunctionEntryLogicTraits WARN_UNUSED ALWAYS_INLINE GetBaselineJitFunctionEntryLogicTrait(bool takesVarArg, size_t numFixedArgs)
{
    TestAssertImp(x_use_som_call_semantics, !takesVarArg);
    if (!takesVarArg)
    {
        constexpr size_t x_novaThres = x_jitFunctionEntrySpecializeThresholdForNonVarargsFunction;
        if (numFixedArgs <= x_novaThres)
        {
            return deegen_baseline_jit_function_entry_logic_trait_table_nova[numFixedArgs];
        }
        else
        {
            return deegen_baseline_jit_function_entry_logic_trait_table_nova[x_novaThres + 1];
        }
    }
    else
    {
        constexpr size_t x_vaThres = x_jitFunctionEntrySpecializeThresholdForVarargsFunction;
        if (numFixedArgs <= x_vaThres)
        {
            return deegen_baseline_jit_function_entry_logic_trait_table_va[numFixedArgs];
        }
        else
        {
            return deegen_baseline_jit_function_entry_logic_trait_table_va[x_vaThres + 1];
        }
    }
}

inline JitFunctionEntryLogicTraits WARN_UNUSED ALWAYS_INLINE GetDfgJitFunctionEntryLogicTrait(bool takesVarArg, size_t numFixedArgs)
{
    if (!takesVarArg)
    {
        constexpr size_t x_novaThres = x_jitFunctionEntrySpecializeThresholdForNonVarargsFunction;
        if (numFixedArgs <= x_novaThres)
        {
            return deegen_dfg_jit_function_entry_logic_trait_table_nova[numFixedArgs];
        }
        else
        {
            return deegen_dfg_jit_function_entry_logic_trait_table_nova[x_novaThres + 1];
        }
    }
    else
    {
        constexpr size_t x_vaThres = x_jitFunctionEntrySpecializeThresholdForVarargsFunction;
        if (numFixedArgs <= x_vaThres)
        {
            return deegen_dfg_jit_function_entry_logic_trait_table_va[numFixedArgs];
        }
        else
        {
            return deegen_dfg_jit_function_entry_logic_trait_table_va[x_vaThres + 1];
        }
    }
}
